# **Спецификация для Frontend‑разработчика (OpenWebUI, ИИ‑ассистент закупок «Северная»)**
## **1\. Цель и зона ответственности**
Этот документ описывает, **как фронтенд (OpenWebUI \+ кастомные виджеты)** должен работать с backend‑API проекта «ИИ‑ассистент закупок».
Фокус:
1. **Draft Widget** — виджет черновика карточки товара.  
2. **Duplicates Widget** — виджет списка дублей/аналогов по данным витрины.
Документ фиксирует:
1. входные JSON‑структуры, которые фронтенд получает от backend;  
2. состав полей, контролов и действий в каждом виджете, с привязкой к эндпоинтам;  
3. требования к HTML/CSS (Tailwind) и адаптивности;  
4. стандартные UX‑флоу и состояния загрузки/ошибок;  
5. мини дизайн‑систему для карточек, бейджей и кнопок.
Связанные документы:
1. API‑контракт: `ИИ_северная_API.md`.  
2. Backend‑спека: `ИИ_Северная_BE.md`.  
3. Диаграммы и контекст: `ИИ_северная_диаграммы.md`.
## **2\. Общие принципы интеграции с OpenWebUI**
### **2.1. Модель взаимодействия**
1. **Источник данных**: backend FastAPI `/api/v1` (см. `ИИ_северная_API.md`).  
2. **Встраивание в чат**:  
3. В ответ на ingestion/редактирование backend возвращает **фрагмент HTML‑виджета** в поле `html_widget`.  
4. OpenWebUI вставляет этот HTML в сообщение ассистента.  
5. **Интерактивность**:  
6. Все действия пользователя в виджетах (кнопки/формы) должны приводить к HTTP‑вызовам backend через механизм **Tools / Actions** в OpenWebUI.  
7. Рекомендуется использовать data‑атрибуты (`data-action`, `data-draft-id`, и т.п.) и единый JS‑обработчик на стороне OpenWebUI, чтобы не прошивать URL'ы и схемы в каждом фрагменте HTML.  
8. **Безопасность**:  
9. В HTML‑фрагментах **запрещены `<script>`**, инлайновый JS и небезопасные события (`on*`‑атрибуты).  
10. Допустимы только разметка, Tailwind‑классы и дата‑атрибуты.
### **2.2. Tailwind и layout**
1. Библиотека стилей: **TailwindCSS**, базовая цветовая тема — нейтральная (серый/синий).  
2. Общие правила:  
3. Корневой контейнер виджета: `max-w-3xl w-full mx-auto`.  
4. На мобильных (`<768px`) — **одна колонка**, отступы `px-3 py-3`.  
5. На десктопе (`≥768px`) — допускается **две колонки** через `md:grid md:grid-cols-[minmax(0,2fr)_minmax(0,1fr)] md:gap-6`.  
6. Фон виджета: `bg-white dark:bg-slate-900`, рамка `border border-slate-200 dark:border-slate-700`, скругление `rounded-lg`, тень `shadow-sm`.
### **2.3. Общие UX‑принципы**
1. Язык интерфейса: **русский**, короткие и однозначные подписи.  
2. Все сетевые действия должны иметь явные состояния:  
3. `idle` → `loading` → `success`/`error`.  
4. Время любых операций \> 400 мс должно сопровождаться **визуальной обратной связью** (спиннер, skeleton, disabled‑состояние кнопки).  
5. Ошибки backend отображаются **человекочитаемо**, но с техническим кодом в дополнительной строке (например, `VALIDATION_ERROR`).
### **2.4. OpenWebUI Tool Integration**
Для взаимодействия с Backend используется **Native Tool** (Python‑скрипт внутри OpenWebUI).
1. **Название Tool**: `procurement_api` (или аналогичное).  
2. **Механизм**:  
3. HTML‑виджеты содержат `data-action` и параметры.  
4. JS‑обработчик в OpenWebUI (или явный вызов пользователем) инициирует вызов Tool функции.  
5. Tool выполняет HTTP‑запрос к Backend (`http://backend:8001/api/v1/...`), используя `OPENWEBUI_TOOL_TOKEN`.  
6. **Функции Tool**:  
7. `ingest_url(url: str)` → `POST /ingest/url`  
8. `search_analogs(query: str, draft_id: str)` → `POST /search/analogs`  
9. `update_draft(draft_id: str, data: dict)` → `PATCH /drafts/{id}`  
10. `commit_draft(draft_id: str)` → `POST /drafts/{id}/commit`
## **3\. Draft Widget — виджет черновика карточки товара**
### **3.1. Назначение**
Показывает и позволяет редактировать **черновик карточки товара**, созданный через ingestion по ссылке/файлу/тексту, и подготовить его к отправке в 1С.
Размещается:
1. как основной виджет в ответ на `POST /ingest/url|file|text`;  
2. как обновлённый виджет после `PATCH /drafts/{id}` и `POST /drafts/{id}/generate-name`.
### **3.2. Входные данные из Backend**
Draft Widget логически опирается на два источника:
1. **Ресурс черновика** (`GET /drafts/{id}`) — модель `DraftCard` (см. `ИИ_северная_API.md`):
{  
"id": "uuid",  
"status": "new | ready\_to\_sync | synced | sync\_error",  
"extracted\_data": { "...": "..." },  
"final\_data": {  
"kind": "string",  
"type": "string",  
"brand": "string",  
"article": "string",  
"specs": {},  
"description": "string",  
"images": \[\]  
},  
"predictions": {  
"gau": { "code": "001", "confidence": 0.95 },  
"duplicates\_count": 1  
},  
"erp\_ref\_key": "string | null"  
}
1. **Объединённая view‑модель для виджета** (формируется на стороне backend при генерации HTML, но важна для фронтенда как логика):
{  
"schema\_version": "draft\_widget\_v1",  
"draft": { /\* объект DraftCard \*/ },  
"meta": {  
"can\_edit": true,  
"can\_commit": true,  
"source\_label": "Ссылка",  
"created\_at": "2025-01-01T12:00:00Z"  
}  
}  
NB: В текущем контракте backend **возвращает уже готовый HTML** в `html_widget`. JSON‑view‑модель выше приведена как логический ориентир; при переходе к JSON‑виджетам (рендер на стороне OpenWebUI) она может быть вынесена в отдельное поле `widget_data`.
### **3.3. Структура UI и поля**
Draft Widget логически разбит на блоки:
1. **Заголовок карточки**  
2. Название товара (основное поле, может быть сгенерировано LLM).  
3. Статус черновика (`status`) как цветной бейдж.  
4. Информация об источнике (URL/файл/текст).  
5. **Блок «Основные реквизиты»** (`final_data`)  
6. Поле `kind` — «Вид номенклатуры» (строка, обязательное).  
7. Поле `type` — «Тип / категория» (строка, опционально; в будущем может быть select).  
8. Поле `brand` — «Бренд / производитель» (строка, опционально).  
9. Поле `article` — «Артикул поставщика» (строка, опционально).  
10. **Блок «Описание»**  
11. Поле `description` — многострочный `textarea`.  
12. **Блок «Характеристики»**  
13. Отображает `final_data.specs` как список пар «Название характеристики» → «Значение».  
14. Для MVP достаточно read‑only; в дальнейшем — таблица с editable строками.  
15. **Блок «Прогнозы и статус интеграции»**  
16. `predictions.gau` — «Предлагаемый код ГАУ: 001 (0.95)».  
17. `predictions.duplicates_count` — краткое резюме: «Найдено 3 возможных дубля/аналога» (линк или якорь к Duplicates Widget).  
18. `erp_ref_key` при `status = synced` — ссылка «Создана карточка в 1С (GUID ...)».  
19. **Панель действий**  
20. Кнопка **«Сохранить изменения»**.  
21. Кнопка **«Сгенерировать название»**.  
22. Кнопка **«Отправить в 1С»** (commit).
#### **3.3.1. Поля и контролы (детализация)**
1. **Название товара (title)**  
2. Источник: для MVP — берётся из `final_data.description`/`extracted_data.data.name` и отображается в заголовке.  
3. Контрол: `input[type="text"]`.  
4. Подпись: «Название товара».  
5. Обязательное поле: да.  
6. **Вид номенклатуры (`kind`)**  
7. Контрол: `input[type="text"]`.  
8. Подпись: «Вид номенклатуры».  
9. **Тип / категория (`type`)**  
10. Контрол: `input[type="text"]` (в дальнейшем — select).  
11. Подпись: «Тип / категория».  
12. **Бренд (`brand`)**  
13. Контрол: `input[type="text"]`.  
14. Подпись: «Бренд / производитель».  
15. **Артикул (`article`)**  
16. Контрол: `input[type="text"]`.  
17. Подпись: «Артикул поставщика».  
18. **Описание (`description`)**  
19. Контрол: `textarea` 4–6 строк.  
20. Подпись: «Описание товара».  
21. **Характеристики (`specs`)**  
22. Отображение: таблица / список из пар `ключ` → `значение`.  
23. Для MVP: read‑only, без редактирования.
### **3.4. Действия и привязка к эндпоинтам**
#### **3.4.1. Сохранение изменений**
1. **Триггер**: клик по кнопке «Сохранить изменения».  
2. **Endpoint**: `PATCH /drafts/{id}`.  
3. **Тело запроса** (пример):
{  
"final\_data": {  
"kind": "...",  
"type": "...",  
"brand": "...",  
"article": "...",  
"description": "..."  
}  
}
1. **Ожидаемый ответ** (`200 OK`):
{  
"draft\_id": "uuid",  
"updated\_fields": \["kind", "brand", "description"\],  
"html\_widget": "\<div class='...'\>...\</div\>"  
}
1. **Поведение виджета**:  
2. Пока запрос в полёте — кнопка «Сохранить изменения» в состоянии `loading` и `disabled`.  
3. После успеха — виджет полностью перерисовывается из `html_widget`.  
4. При ошибке — показывается toast (см. 5.4) \+ inline‑ошибка внизу формы.
#### **3.4.2. Генерация названия**
1. **Триггер**: клик по кнопке «Сгенерировать название».  
2. **Endpoint**: `POST /drafts/{id}/generate-name`.  
3. **Тело запроса**: пустое (`{}`).  
4. **Ответ**:
{ "generated\_name": "..." }
1. **Поведение**:  
2. При успехе фронтенд **обновляет поле «Название товара»** и помечает форму как изменённую.  
3. Рекомендуется **автоматически выполнить `PATCH /drafts/{id}`** для фиксации названия, либо предложить пользователю нажать «Сохранить изменения».
#### **3.4.3. Отправка черновика в 1С (commit)**
1. **Триггер**: клик по кнопке «Отправить в 1С».  
2. **Endpoint**: `POST /drafts/{id}/commit`.  
3. **Ответ** (`200 OK`):
{ "status": "ready\_to\_sync" }
1. **Поведение**:  
2. Кнопка переходит в состояние loading до ответа.  
3. После успеха:  
   1. статус в виджете меняется на «Готов к синхронизации» (`ready_to_sync`),  
   2. кнопка commit скрывается или дизейблится,  
   3. показывается toast «Черновик отправлен в 1С. Статус: готов к синхронизации».  
4. Периодический опрос для получения `synced` и `erp_ref_key` выполняется за пределами виджета, через ассистента.
### **3.5. UX‑флоу**
#### **3.5.1. Создание черновика по ссылке**
1. Пользователь в чате вводит: «Создай карточку по ссылке …».  
2. Ассистент вызывает tool `ingest_source` → backend `POST /ingest/url`.  
3. В OpenWebUI показывается **skeleton Draft Widget** с текстом «Создаю черновик по ссылке…».  
4. При ответе backend:  
   1. если `200 OK` — берётся `html_widget` и skeleton заменяется на реальный Draft Widget;  
   2. если ошибка — skeleton скрывается, показывается toast с текстом ошибки.
#### **3.5.2. Редактирование и сохранение**
1. Пользователь меняет поля `brand`, `article`, `description`.  
2. Жмёт «Сохранить изменения».  
3. Виджет отправляет `PATCH /drafts/{id}`.  
4. На время запроса:  
5. кнопка «Сохранить изменения» — `loading`/`disabled`;  
6. остальные поля **не блокируются**, но изменения после отправки могут быть перезаписаны перерисовкой HTML.  
7. При успехе — виджет заменяется ответным `html_widget`.  
8. При ошибке — toast \+ подсветка ошибки.
#### **3.5.3. Генерация названия и commit**
1. **Генерация названия**:  
   1. Пользователь жмёт «Сгенерировать название».  
   2. Появляется лоудер на кнопке, после ответа — поле «Название товара» заполняется.  
2. **Commit**:  
   1. После проверки полей пользователь жмёт «Отправить в 1С».  
   2. Виджет обновляет статус и показывает подсказку, что синхронизация выполняется в фоне.
### **3.6. Состояния: загрузка и ошибки**
1. **Skeleton‑состояние** (пока нет данных черновика):  
   1. Карта с `animate-pulse`, серые прямоугольники вместо текста.  
2. **Loading‑состояние кнопок**:  
   1. Класс `opacity-70 cursor-not-allowed` \+ иконка спиннера слева от текста.  
3. **Ошибка сохранения**:  
   1. Toast поверх виджета (см. 5.4): «Не удалось сохранить изменения. Попробуйте ещё раз.»  
   2. Технический код из `error.code` во второй строке.
### **3.7. HTML/CSS‑ограничения для Draft Widget**
1. **Корневой контейнер**:  
   1. `div.severnaya-draft-widget`.  
   2. Классы: `max-w-3xl w-full mx-auto bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-700 rounded-lg shadow-sm p-4 md:p-6 space-y-4`.  
2. **Заголовок**:  
   1. Flex‑контейнер: `flex flex-col md:flex-row md:items-start md:justify-between gap-2`.  
   2. Название: `text-lg font-semibold text-slate-900 dark:text-slate-50`.  
   3. Статус‑бейдж — см. 5.2.  
3. **Секции формы**:  
   1. Обёртка: `space-y-4`.  
   2. Каждый блок: `border-t border-slate-100 dark:border-slate-800 pt-4`.  
4. **Инпуты** — см. 5.3 (Form controls).
## **4\. Duplicates Widget — виджет дублей и аналогов**
### **4.1. Назначение**
Показывает список найденных **дублей и аналогов** по витрине номенклатуры 1С для текущего черновика.
Используется:
1. в составе основного ответа после ingestion (справа от Draft Widget или под ним);  
2. по явному запросу пользователя «Покажи аналоги».
### **4.2. Входные данные из Backend**
Источник данных — endpoint `POST /search/analogs` (см. API‑спеку):
{  
"query": "Мышь logitech", // опционально  
"draft\_id": "uuid" // опционально  
}
Ответ:
{  
"results": \[  
{  
"ref\_key": "guid",  
"name": "Mouse Logitech",  
"score": 0.98,  
"match\_type": "duplicate" // duplicate | analog | related  
}  
\]  
}
Для Duplicates Widget логическая view‑модель:
{  
"schema\_version": "duplicates\_widget\_v1",  
"draft\_id": "uuid",  
"items": \[ /\* элементы results \*/ \],  
"meta": {  
"query": "Мышь logitech",  
"total": 10,  
"shown": 5  
}  
}
### **4.3. Структура UI и поля**
1. **Заголовок блока**  
   1. Текст: «Найденные дубли и аналоги».  
   2. Подзаголовок: «Показаны N из M».  
2. **Список карточек кандидатов**  
   1. Одна карточка на строку; максимум 5–10 элементов в видимом списке.  
   2. Параметры карточки:  
      1. `name` — основной заголовок.  
      2. `match_type` — бейдж по типу совпадения (`duplicate` / `analog` / `related`).  
      3. `score` — левосторонний текст «score 0.98» или прогресс‑бар.  
      4. `ref_key` — технический GUID 1С (отображать мелким шрифтом).  
3. **Панель действий**  
4. Кнопка «Обновить по черновику» — перезапускает поиск с `draft_id`.  
5. Поле поиска \+ кнопка «Искать по тексту» — запускает поиск с `query`.
### **4.4. Действия и привязка к эндпоинтам**
#### **4.4.1. Обновление по черновику**
1. **Триггер**: клик по кнопке «Обновить по черновику».  
2. **Endpoint**: `POST /search/analogs`.  
3. **Тело запроса**:
{ "draft\_id": "uuid" }
1. **Поведение**:  
2. На время запроса список заменяется skeleton‑карточками.  
3. После успеха — список перерисовывается по `results`.
#### **4.4.2. Поиск по тексту**
1. **Триггер**: ввод текста в поле и клик по «Искать по тексту».  
2. **Endpoint**: `POST /search/analogs`.  
3. **Тело запроса**:
{  
"query": "строка поиска",  
"draft\_id": "uuid" // опционально, для учёта черновика  
}
1. **Поведение**:  
2. Аналогично обновлению по черновику.
### **4.5. UX‑флоу**
1. После успешного создания черновика ассистент (или виджет) вызывает `POST /search/analogs { "draft_id": draft_id }`.  
2. Пока ответ не получен — показывается skeleton из 3–5 карточек.  
3. После ответа — Duplicates Widget показывает список кандидатов.  
4. Пользователь при необходимости повторяет поиск с другим текстом.
### **4.6. Состояния и HTML/CSS‑ограничения**
1. **Корневой контейнер**:  
2. `div.severnaya-duplicates-widget`.  
3. Классы: `max-w-3xl w-full mx-auto bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-700 rounded-lg shadow-sm p-4 md:p-6 space-y-3`.  
4. **Список карточек**:  
5. Обёртка: `space-y-2`.  
6. Карточка кандидата: базовый компонент Card (см. 5.1).  
7. **Skeleton‑карточки**:  
8. Используют те же размеры, но внутри только серые блоки `bg-slate-200 dark:bg-slate-800 animate-pulse`.
## **5\. Мини дизайн‑система компонентов**
### **5.1. Card (карточка)**
Базовый контейнер для Draft Widget и элементов списка дублей.
1. Классы:  
2. `rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900 shadow-sm p-3 md:p-4`.  
3. Дополнительно для интерактивных карточек (кликабельных):  
4. `hover:bg-slate-50 dark:hover:bg-slate-800 cursor-pointer transition-colors`.
### **5.2. Badges (бейджи статусов)**
#### **5.2.1. Статус черновика (`status`)**
1. **new** — «Новый»  
2. `inline-flex items-center rounded-full bg-slate-100 text-slate-700 dark:bg-slate-800 dark:text-slate-100 px-2 py-0.5 text-xs font-medium`.  
3. **ready\_to\_sync** — «Готов к синхронизации»  
4. `bg-amber-100 text-amber-800 dark:bg-amber-900/40 dark:text-amber-200`.  
5. **synced** — «Синхронизирован с 1С»  
6. `bg-emerald-100 text-emerald-800 dark:bg-emerald-900/40 dark:text-emerald-200`.  
7. **sync\_error** — «Ошибка синхронизации»  
8. `bg-red-100 text-red-800 dark:bg-red-900/40 dark:text-red-200`.
#### **5.2.2. Тип совпадения (`match_type`)**
1. **duplicate** — «Дубль»  
2. `bg-red-100 text-red-800 dark:bg-red-900/40 dark:text-red-200`.  
3. **analog** — «Аналог»  
4. `bg-blue-100 text-blue-800 dark:bg-blue-900/40 dark:text-blue-200`.  
5. **related** — «Похожий»  
6. `bg-slate-100 text-slate-700 dark:bg-slate-800 dark:text-slate-100`.
### **5.3. Buttons (кнопки)**
Базовый класс кнопки:
1. Общие классы:  
   1. `inline-flex items-center justify-center gap-1.5 rounded-md text-sm font-medium focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-blue-500 disabled:opacity-60 disabled:cursor-not-allowed transition-colors`.
Варианты:
1. **Primary** (основные действия: «Сохранить», «Отправить в 1С»)  
   1. `bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-600 dark:hover:bg-blue-500`.  
2. **Secondary** (вспомогательные действия: «Сгенерировать название»)  
   1. `bg-slate-100 text-slate-900 hover:bg-slate-200 dark:bg-slate-800 dark:text-slate-50 dark:hover:bg-slate-700`.  
3. **Ghost** (малозаметные действия: «Обновить по черновику»)  
   1. `bg-transparent text-slate-700 hover:bg-slate-100 dark:text-slate-200 dark:hover:bg-slate-800`.
Размеры:
1. **Base**: `h-9 px-3`.  
2. **Small**: `h-8 px-2.5 text-xs`.
Состояние loading:
1. Добавить к кнопке модификатор класса `data-loading="true"` и визуально:  
2. prepend‑иконка‑спиннер (`animate-spin h-4 w-4`),  
3. текст затемняется `opacity-80`.
### **5.4. Toast / уведомления**
Простой toast‑паттерн, встраиваемый в DOM OpenWebUI поверх сообщений.
1. Контейнер:  
2. `fixed inset-x-0 bottom-4 z-50 flex justify-center px-4`.  
3. Внутри — `max-w-md w-full`.  
4. Карточка уведомления:  
5. `rounded-md border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2 shadow-md flex flex-col gap-0.5 text-sm`.  
6. Типы:  
7. **success** — левая полоса/иконка зелёная.  
8. **error** — левая полоса/иконка красная.  
9. Текст:  
10. Первая строка — человекочитаемое сообщение.  
11. Вторая строка (опционально) — `Код: ERROR_CODE` из backend.
### **5.5. Form controls (инпуты и textarea)**
1. Общая стилизация input/textarea/select:  
   1. `block w-full rounded-md border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-2.5 py-1.5 text-sm text-slate-900 dark:text-slate-50 shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-1 focus-visible:ring-offset-slate-50 dark:focus-visible:ring-offset-slate-900 placeholder:text-slate-400`.  
2. Лейблы:  
   1. `mb-1 block text-xs font-medium text-slate-700 dark:text-slate-300`.  
3. Help‑текст / ошибки:  
   1. `mt-1 text-xs text-slate-500 dark:text-slate-400`.  
4. Ошибка: `text-red-600 dark:text-red-400`.
### **5.6. Skeleton‑элементы**
Используются для загрузки Draft/Duplicates widgets.
1. Базовый skeleton‑блок:  
2. `h-4 w-24 rounded bg-slate-200 dark:bg-slate-800 animate-pulse`.  
3. Для заголовков: `h-5 w-1/2`.  
4. Для текста: `h-3 w-full` с несколькими строками.
## **6\. TBD / Открытые вопросы для Frontend**
1. Переход от возврата готового HTML (`html_widget`) к возврату JSON‑виджетов (`widget_data`) и рендеру на стороне OpenWebUI.  
2. Расширение `final_data.specs` до полноценного редактируемого списка (добавление/удаление характеристик в UI).  
3. Возможность действий по дублям (например, «Пометить как дубль / аналог» с отдельным endpoint'ом backend).  
4. Интеграция с тёмной темой OpenWebUI (проверить фактические цвета и токены Tailwind в используемой сборке).  
5. Роуты для открытия карточки 1С по `ref_key` (если понадобится прямой линк из Duplicates Widget).

